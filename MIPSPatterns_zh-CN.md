# MIPSPatterns_zh-CN

## 01a-LabelsAndSections

在MIPS中，你需要熟悉2种特定的程序组成段（section）：第一种是**数据段**（data section），第二种是**文本段**（text section）。数据段用于静态分配数据，而文本段用于保存代码。

**标签（labels）**是用来标识内存区域的名称。程序员可以使用这些名称抽象地引用内存位置。汇编器最终会将它们转换为二进制文件中的适当地址*（至于是如何转换的，可以阅读《计算机组成与设计：软硬件接口》*。在这里，内存区域既可以指数据空间，也可以指代码空间。当用于数据时，你通常认为它们是命名变量，可以读取和写入。当用于代码时，你通常认为它们是存储过程（procedure）名称（procedure：完整程序中的一段完成一定功能的代码，如一段循环）或跳转/分支目的地。

下面这个就是所谓的**指令（directive）**。指令总是以句号开始。此处开始数据部分。这里没有代码，只有静态数据。通常情况下，在考虑样式时，我们会让段指令（section directives）不加缩进，单独放在一行中，这样我们就能很快看到章节的变化。

```assembly
.data
#.data 这是不加缩进
```

下面这个是一个标签（label）。标签是由字母、数字和下划线组成的字符串。它们还必须以字母或下划线开头，而不能是单独的一个下划线。也可以对标签加缩进，但通常不会这么干。该标签是单个静态分配字节的地址（在 01b-DataSection 中讨论）。标签不必单独出现在一行中，因此下面这些都是可接受的代码。

```assembly
exampleLabel1:#不加缩进
  .space 1#内容：加缩进

exampleLabel2: .space 1#标签与内容在同一行中
```

下面这条指令标志着文本段的开始（用于代码）。

```assembly
.text
```

下面这个标签可以是跳转或分支的目的地。跳转后将从冒号后的第一条指令开始执行。如果在 标签的同一行有一条指令，则会从该行开始执行，否则将从标签后的指令开始执行。

```assembly
# This starts execution at the following line.
foo:
  add   $t0, $zero, $zero         # Foo starts here.
  jr    $ra                       # Foo ends here.

# This starts execution on the same line.
bar:  add   $t0, $zero, $zero     # Bar starts here.
      jr    $ra                   # Bar ends here.

# This starts execution many lines later.
baz:


  add   $t0, $zero, $zero         # Baz starts here.
  jr    $ra                       # Baz ends here.
```

## 01b-DataSections

数据段（data sec）用于为变量分配静态空间。下面是一些你可能会关心的内容。

下面这条指令标志着数据段的开始。

```assembly
.data
```

以下所有指令都可以通过在指令后添加一个用逗号来分隔的、目标值所组成的列表来初始化。

```assembly
#为字节数据分配空间使用 .byte 指令。
aByte:
  .byte 255

manyBytes:
  .byte 1, 2, 3, 0x55, -128
# 为半字（2 字节）分配空间使用 .half 指令。
aHalfword:
  .half 65535

manyHalfwords:
  .half 256, 0xFFFE, -19

# 为一个字（4 字节、一个 int、一个指针）分配空间时，使用 .word
# directive.
aWord:
  .word 4294967295

manyWords:
  .word 65536, 0xDEADBEEF, -2147483648

# 为浮点数（4 字节，IEEE 754 浮点数）分配空间时，使用 .float
# directive.
aFloat:
  .float 1.0

manyFloats:
  .float -1.0, 1000.0001
```

为字符分配空间有两种方式：使用.ascii 或 .asciiz。第一个指令（.ascii）将产生一个字符数组，而第二个指令（.asciiz）将产生同样的字符数组，但会在末尾添加一个空字符。因此，如果只需要字符数组，使用 .ascii 可能更合适，而 .asciiz 则适合打印字符串。重要的是要记住，字符只是具有特定值的字节，请参阅此处http://www.asciitable.com/index/asciifull.gif

例如，像下面的这些字符（串）都是等价的。

```assembly
hwString:
  .asciiz "Hello world!"

hwChars:
  .ascii "Hello world!"
  .byte 0x00
  #手动添加最后的一个空字节，达到了和.asciiz相同的效果

hwBytes:
  .byte 0x48, 0x65, 0x6C, 0x6C, 0x6f, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21
  .byte 0x00
```

另外，如果你只想请求一段未初始化的数据空间（用于数组或类似的东西），可以使用 .space 指令。这将给你所请求的未初始化空间的字节数。

todo:对应C语言中的？

```assembly
# Space for 16 words.
someSpace:
  .space 64

```

## 02a-Subroutines

子程序（Subroutine）也称为过程（procedure）或函数（function），以标签（Label）开始，通常以使用返回地址寄存器 ($ra) 的跳转寄存器 (jr) 指令结束。

当一个子程序不调用任何其他函数时，它可以被称为 "叶子函数"。如果把程序的路径看作一棵树，函数调用(function call)就是树枝，那么不调用任何其他函数的子程序就是路径的末端或叶子。

下面是一个名为foo的函数。注意，这仍然只是一个普通的标签，我们只是选择将其视为一个子程序。

```assembly
foo:
# 函数代码。堆栈wind、函数工作、其他过程调用、堆栈展开等。由于某种原因在函数中出现的标签，可能是作为循环、条件等的一部分的分支或跳转目的地，你可以考虑在标签名称前加上不同的前缀，以便将它们与函数标签区分开来。
_fooLabelName:
#返回指令。只有一个或尽可能少的出口通常是个好主意，这样你只需要管理几个出口点。
	jr    $ra
```

## 02b-ArgRegisters参数寄存器

```assembly
.text
# 一个名为sum的函数
sum:
# 函数需要访问数据来执行有意义的操作。获取这些数据的典型方法是通过参数（其他选项包括 # 堆栈和静态数据分配）。MIPS 有四个参数寄存器：$a0、# $a1、$a2 和 $a3。

# 例如下面这个函数sum(a,b,c,d)把它的四个参数a b c d加起来并打印出来
# 下面这行代码将前两个参数加起来。我们使用$t0作为累加寄存器
	add $t0,$a0,$a1
# 下面这行代码将头两个参数加在一起
	add $t0,$t0,$a2
	add $t0,$t0,$a3
# 准备打印——把sum的结果放入第一个参数寄存器，并设置"print int"的系统调用（syscall）
	move $a0, $t0
	li $v0, 1
# 打印
	syscall
# 返回
	jr $ra
```

## 03C-返回寄存器

通常来说，一个函数在被调用后需要把数据返回给调用它的人（函数）。一种典型的方式是把数据返回（另一种方式是栈和静态数据分配）。大部分高级语言允许返回一个数据（尽管这个数据可以是许多数据的组合体），而MIPS有两个返回寄存器，允许返回2个数据，但这些返回数据的大小都被限制为一个寄存器的位宽（一个字）这些通常用于数据(data)寄存器（\$v0）和信息(info)寄存器(\$v1)。这个信息可以是一个用于标志成功与否的布尔值，也可以是写入字节的长度。实际上，这些寄存器的含义取决于编程者，当你在编写函数时可以自行决定它们的含义。

下面是一个函数例子sumAndSquare(a,b,c,d)把四个参数加起来，并将求和值返回到\$v0，将求和值的平方返回到\$v1。

```assembly
.text
sumAndSquare:
	add $t0,$a0,$a1
	add $t0,$t0,$a2
	add $t0,$t0,$a3
	#把求和结果放到v0寄存器
	move $v0,$t0
	#计算平方值（乘法会产生64为并且最终会把它的结果放道2个特别的寄存器lo和hi中，对此可以查看伪指令mul）
	mult $t0,$t0
	#准备返回平方值
	mflo $v1
	#返回
	jr $ra
```

## 02D-Mains

如果你正在编写一个完整的程序，而不仅仅是一个函数，那么你需要一个程序入口点。

在C语言中，我们称之为main，在MIPS中也是一样。

main函数自身实际上只是一个子程序，它被启动代码所调用（start up code）

```assembly
# main函数必须在.text段中，因为它是代码
.text
# 接下来的事情很简单，只需要设置一个名为main的labe即可。你的程序会从这个label开始执行（经过一些前置处理工作，不过这些工作不会显示在表面上）
main:
	# Main code
	# Man函数的返回值是一个整型，当main成功执行后通常返回0
	li $v0,0
	jr $ra
```

# 03-Conditionals条件语句

## 03a-if

请注意，汇编中的条件语句与你通常想要编写的内容是相反的。这是因为一般情况下我们会想“在这种情况下,我应该执行这段代码”。但在汇编中，因为汇编总是按顺序执行的，我们必须这样想“在这种情况下，我会让程序继续按顺序执行”。反过来，我们也可以这样想“如果不是这种情况，我希望程序不要继续按顺序执行”。因为我们希望有机会围绕这段代码建立条件分支，所以我们通常采用上面的第二种想法来插入分支。

因此我们可以把原来的想法“if \$t0 == 0 , do this”转变为" if \$t0 != 0， don't do this "。后者对应的是在我们希望跳过的代码部分建立分支。当\$t0不等于0的时候我们建立分支。MIPS中的语句BRANCH NOT EQUAL让我们能很方便地达成这个效果。

```assembly
.text
f1:
	#if ($t0 == 0){do sth}
	bne $t0, $zero, _f1Join
	
	#如果我们经过了bne指令但并没有执行它，说明$t0 == 0
	#接下来就是$t0 == 0的情况下所要执行的代码
	# your code 
	#不需要通过jump跳转到join point，只需要让你的代码顺序执行（fall through）到join point即可
# join point：在这个标签之后的内容会被两种分支所共同使用
_f1Join:
	# your code
	jr $ra
```

## 03b - if-else

```assembly
.text
f2:
#假设我们希望拥有一个单独的if语句和一个无条件的else语句块，使用与上一节一样的条件
#if ($t0== 0){do sth}
#else{do sth if false}

# 基本思想与03a-if中的是一致的，使用相反的条件判断去跳过我们不希望执行的代码。不同之处在于如果条件判断为不符合，我们跳转到别的代码块，并且最终两个代码块都会指向join point
	bne $t0, $zero, _f2Else
	# then block
	
	j _f2Join
	
_f2Else:
	#到达这里，说明进入else分支
	#your code
	#可以直接令其顺序执行到join point
_f2Join:
	#条件分支结束后的代码
	jr $ra
```

## 03c else-if

```assembly
.text

# 含有if/elif/else 条件判断的函数
f3:
  # ...

  # 我们希望产生多个排他条件句（只有一个条件分支会被执行）
  # 我们尝试制造像这样的分支语句：
  # if ($t0 == 1) { ..do something.. }
  # elif ($t0 == 2) { ..do something.. }
  # else { ..do something.. }

  # 在汇编中有两种方式达到这样的效果。 第一种相对直观且易于维护。
  # 第二章会在03d中解释，但你只需要掌握其中一种就可以了

  # 这里采用了一种与之前稍微不同的思路. 我们需要把所有的条件句收集在同一个地方(条件句的顶层)并分支到对应的代码块。
  # 不同于之前的思路（跳过某个情况下的代码块）而是在遇到该情况时进行分支。我们可以无限堆叠这种模式，来获得无限的if/elif/else代码块
  # setup/branch-if-true pattern
  
  # 在此处放置第一个条件分支检测。本例中我们需要检查$t0==1,所以只需要一条指令就可以了
  # 我们假设$t0现在是空闲状态，放入1
  li    $t1, 1

  # 因为在这之后还有其他条件分支直接跟随此分支转到其他代码块，所以我们希望在两个值相等时分支以达到到正确的代码块。同样方便的是，MIPS 有 beq 指令。
  #分支1
  beq   $t0, $t1, _f3Body1

  # 为下一次条件判断检测做准备
  # 将 1 加到 $t1，然后放回 $t1，从而将 1 增为 2。
  addi  $t1, $t1, 1

  # 与第一个分支的逻辑相同，如果条件为true，进行分支
  #分支2
  beq   $t0, $t1, _f3Body2

  # 我们已经满足了所有条件。如果我们到达这里，那么我们就知道所有的if条件都没有得到满足。如果有 else 块，那么我们必须通过无条件跳转到它来执行它。如果没有 else 块（即 if/elif 没有 else），那么我们无条件跳转到 join 块。

  # 我们有一个 else 代码块，所以跳转到它。
  #分支3
  j     _f3Else
  # 或者，如果没有 else 代码块： j _f3Join

_f3Body1:
  # We passed if condition one, do if then block.
  # ...

  # We don't want to execute any of the other blocks, so jump to the join point.
  j     _f3Join

_f3Body2:
  # We failed condition one but passed condition two, do the elif then block.
  # ...

  # We don't want to execute any of the other blocks, so jump to the join point.
  j     _f3Join

_f3Else:
  # We didn't pass any conditions so do the else block.
  # ...

  # There's nothing between us and the join block so we can just fall through.

_f3Join:
  # Code after the conditional.
  # ...

  jr    $ra
```

# 04-Loops

## 04a-PreconditionLoops

```assembly
.text 
# 一个包含了前提条件的循环的函数
f1:
	#这个循环包含一个"前提条件"：一个在每次迭代的开始都进行计算的条件。这是我们通常情况下所认为的循环的方式，故而也是最易于推理和使用的循环
  # 我们将要设置一个简单的循环，像这样：
  # for (i = 0; i < 10; ++i) { ... }
  #      ----- +++++++ ****   ^^^^^
  #        1      2      3      4
  # 上面的示意图中对各个字段进行了下划线处理，便于后文的标注
  # 我们需要通过循环来追踪迭代过程，这意味着我们需要同时保留两个值：计数器和最大值。这意味着使用两个寄存器
  # 这些寄存器可能已经被之前的代码填满，但我们假设要让一个循环执行十次，因此将一个寄存器设置为 0，另一个寄存器设置为 10。假设 $t0 和 $t1 在这里是空闲的
  # ----------  1  ------------
  move $t0, $zero
  li $t1,10

_f1LoopBegin:
	# 标签后的第一件事应该是判断循环条件，这也是我们每次完成一轮迭代后都要跳转到的地方
	# ++++++++  2  +++++++++++
	bge $t0,$t1,_f1Join
	#注意此处使用的是t寄存器。不同于条件寄存器（对于条件寄存器，第一次使用后就不需要再关心用于检查条件的寄存器了），在循环中我们需要保留这些寄存器的值。如果你进行了调用（jal），你需要意识到调用约定允许这些寄存器的值被破坏。你必须在调用之前保存t寄存器，并在调用结束后恢复这些寄存器的值。如果你更喜欢用s寄存器，你可以分别在函数的开头和结尾处保存和恢复它们。
	#细节参阅06a-SavedRegisterCC and 06c-TemporaryRegisterCC.
	
	# 循环体内容
	# ^^^^^^^^^^^  4 ^^^^^^^^^^^
	
	# 接下来是迭代。
	# ***********  3  *************
	# 迭代是为for循环准备的，而不是while循环。如果你正在编辑一个while循环，那么迭代的部分可能是你循环体内容的一部分，而非单独拆分出来的部分。
	addi $t0, $t0, 1
	# 我们已经完成了这个迭代，所以需要返回到起点，准备下一次迭代。这意味着无条件跳转
	j _f1LoopBegin

_f1Join:
	# 循环结束后的代码
	
	# 返回
	jr $ra
```

## 04b- PostconditionLoops

```assembly
.text
f2:
#该循环有一个后置条件，该条件在每次迭代结束时计算。它有点难以思考，但通常是编译器将高级语言循环转换成的内容。这种形式有点复杂，因为您仍然需要首先检查（称为“guard”）是否满足条件（如 if），但必须在最后依赖另一个条件来终止循环。
	# -------------  1  --------------
  move  $t0, $zero
  li    $t1, 10
  	
  # We're just going to set up the same simple loop as in 04a-PreconditionLoop:
  # for (i = 0; i < 10; ++i) { ... }
  #      ----- +++++++ ****   ^^^^^
  #        1      2      3      4
  # The above also underlines some sections so that we can point them out in the
  # code.
  #我们的初步检查。在这里很容易看到这个分支永远不会被采用，因为我们刚刚设置了它。但是，如果这些是在上面的代码中计算的值，那么这是必要的。该条件也将以与前置条件循环相同的方式表达（即，如果满足该条件，我们希望退出）。重要的是，这是在循环开始标签之前。它不会在每个循环中执行。它只保护第一次迭代。
  # +++++++++++  2  +++++++++++
  bge   $t0, $t1, _f2Join
_f2LoopBegin:

	# ^^^^^^^^^^^  4  ^^^^^^^^^^
	# 循环体内容
	
	# ***********  3  ***********
	addi $t0, $t0, 1
	# 现在检查循环条件。这是后置条件。它几乎一定会是初始检查的否定。原因是我们在想要重新启动循环时才会进行检查，而不是在想要结束循环时进行检查。我们得到的好处是，我们不需要每次迭代都跳回前提条件，而是在完成时直接跳转到连接块。我们希望在计数器小于 10 时继续执行循环。因此我们希望在 $t0 小于 $t1 (blt) 时进行分支。注意 blt 是 bge 的否定。
	# ++++++++++++  2  ++++++++++++++
	blt   $t0, $t1, _f2LoopBegin
_f2Join:
  # Code after the loop.
  # ...

  # Return.
  jr    $ra

```

# 05

## 05a - ands

```assembly
.text 
f1:
	#我们想要的不仅仅是前文提到的简单条件。由于条件或循环的标头可以以很快的速度进行扩展，任何比单个布尔表达式更复杂的内容都需要仔细理解布尔逻辑和程序流程。
	# 我们从 AND (&&) 开始。
	# 我们来检查一下： if ($t0 < 0 AND $t0 != 5) { ...}
	# 布尔运算从左到右进行：首先是 $t0 < 0，然后是 $t0 != 5，如果还有更多，我们就继续向右计算。如果任何布尔值为false，我们就知道不会执行它后面的代码块，也就不必完成对其他条件的评估。这就是所谓的短路。
	# 我们此处使用一个简单的没有else 的if语句，集中于如何处理更加复杂的情况。
	# 随着流程继续，我们会在此基础上继续迭代
	
	#准备条件判断的第一部分如下，但此处可以省略，因为zero值始终在$zero寄存器中
	#现在检查一下条件。如果可以的话，我们希望尽早停止评估（短路）。这意味着如果我们失败了，那么我们可以跳到连接点。 这里失败意味着 t1 >= 0。鉴于此，如果我们大于或等于零 (bge)，进行分支。
	bge   $t0, $zero, _f1Join
	
	# 如果进入此处，说明第一个条件是true，这也意味着我们需要检查第二个条件。
	# 为第二次检测设立条件：
	
	li $t1,5
	
	# 现在检查最后一个条件。如果这种情况失败，我们将转到连接点。条件 $t0 != 5 意味着如果 $t0 等于 5，我们需要进行分支。
	beq $t0,$t1,_f1Join
	#以下是if分支的代码块内容。
	
	#直接顺序执行进入join point
_f1Join:
	jr $ra
	
```

## 02b - ors

```assembly
.text 

f2:
	# 我们现在尝试使用 OR (||)。 
	# 让我们检查一下： if ($t0 % 3 == 0 OR $t0 % 5 == 0) { ... } 
	# 与 AND 类似，OR 也短路，但方式不同。这里，任何 true 值意味着主体代码块将被执行。因此，从左到右评估，如果条件为真，我们可以跳转到主体来执行它。	
	# 以下是检查第一个条件
	li $t1, 3
	div $t0, $t1
	mfhi $t1
	
	#接着检查条件。如果remainder是zero,我们希望执行代码块内容；所以当$t1 == 0 时我们希望分支。我们直接分支到主体代码块内容，没有必要再检查第二个条件。这与我们目前所见的任何情况都不同，因为我们正在执行的内容与原始条件相同。这是因为短路表示我们希望直接执行主体代码块的内容
	beq $t1,$zerom _f2CondBody
	
	# 第一部分的条件判断为false，所以需要检查第二部分
	# 为第二次检查做准备
	
	li $t1, 5
	div $t0, $t1
	mfhi $ti
	# 现在检查最后一个条件。最后一个条件与条件中前面任何条件的区别在于，如果我们在这里判断失败了，那么我们就不应该执行正文。这又是典型的 "反其道而行之"。我们要在 $t1 不等于 0 的情况下分支。我们分支到join point，因为我们没有通过每个条件，或者因为我们通过了这个条件而失败。
	bne $t1, $zero, _f2Join
	
_f2CondBody:
	# 主体代码块
	
_f2Join:
	jr $ra
	
	
```

# 06 -Stacks栈

## 06a-savedRegisters

```assembly
.text

# 这是一个使用了已保存寄存器的叶函数
# 本章的主题会稍微高级一些
f1:
  # 每个子程序都共享相同的寄存器。如果对寄存器的使用方式没有任何规定，开发人员就永远无法使用其他开发人员的函数，因为他们无法确定调用函数是否会破坏寄存器中的值

  # 解决这个问题的方法就是所谓的“调用约定”（calling convention）。调用约定是一组规则，决定了函数在被调用时如何共享寄存器

  # 保存寄存器（saved registers）是指调用函数（caller）在调用另一个函数时可以依赖的寄存器，在调用另一个函数时保持不变。这意味着如果 被调用函数（callee）希望使用这些保存寄存器，就必须在开始执行的时候将这些保存寄存器中的值保存到堆栈中，然后在返回前将它恢复，这样，在caller看来，保存寄存器似乎没有发生任何变化。因此，saved registers有时也被称为 callee saved registers，即“调用者保存的寄存器”

  # 需要记住的是，函数既可以是caller，也可以是callee。当它是callee时，必须保存已保存的寄存器。但当它调用另一个函数时，它可以假定当子函数返回时，saved registers跟调用前是一样的

  # T我们首先要做的是分配堆栈空间。我们通过堆栈指针（$sp）来管理堆栈。堆栈指针是一个高值。当堆栈增长（在堆栈上分配更多空间）时，我们会减小指针。这意味着堆栈向下增长。

  # 我们计划使用寄存器$s0-$s2.
  # 所需要的空间是3 registers * 4 bytes 等于 12 bytes.
  addi  $sp, $sp, -12

  # 现在我们需要保存这些寄存器。由于我们已经分配了空间，我们知道直接将其放入的偏移量，所以没有必要再做数学计算 
  # $sp。
  sw    $s0, 0($sp)               # $s0 is in the first slot.
  sw    $s1, 4($sp)               # $s1 is in the second slot.
  sw    $s2, 8($sp)               # $s2 is in the third slot.

  # 既然我们已经保存了它们，就可以随意覆盖它们或将它们用于任何我们想要的用途。
  # 使用 $s0-$s2 执行函数主体。
  # ...

  # 现在我们完成了函数，需要恢复我们保存的寄存器,这样看起来就像我们没有更改它们一样。再说一遍，我们知道把它们放进了哪个插槽，因此可以使用偏移量立即将它们取出。
  lw    $s2, 8($sp)
  lw    $s1, 4($sp)
  lw    $s0, 0($sp)

  # 你必须始终取消分配堆栈中的空间。如果不这样做,你的调用函数就会假定堆栈指针在正确的位置，当它假定从正确的槽中加载值时，就会加载错误的值。
  addi  $sp, $sp, 12

  # Return.
  jr    $ra
```

## 06b-ReturnAddressCC

```assembly
.text

# 这是一个调用了其他函数的函数
# 相比之前的内容，这部分内容要更高级一些
f1:
  # 如果我们计划调用另一个函数，那么我们将使用 jal 跳转到它。 jal 的“al”部分表示“和链接”，这意味着我们将在 $ra 寄存器中放置一个返回地址。但是，我们只有一个 $ra 寄存器。现在， $ra 中有我们的返回地址，所以如果我们使用 jal 并覆盖它，我们将永远无法返回。所以我们需要保存它。 这样，$ra 也是一个saved register。从技术上讲，$ra 不是一个saved register，但将其视为调用约定的寄存器将使汇编编程变得轻松。

  # 我们保存寄存器的方法与保存其他寄存器的方法相同：在函数开始时将其保存在堆栈中，然后在返回前将其恢复。

  # 向下增长栈指针，一条指令的宽度
  addi  $sp, $sp, -4

  # 保存$ra寄存器到栈中
  sw    $ra, 0($sp)

  # Execute some function code.
  # ...

  # 现在调用子函数，覆盖 $ra的内容，我们不介意这么做，因为我们已经把地址放在一个安全的地方（栈中）
  jal   f2

  # Execute some more function code.
  # ...

  # 返回之前，将$ra的值恢复
  lw    $ra, 0($sp)

  # 恢复栈指针，恢复被分配的空间。
  addi  $sp, $sp, 4

  # 返回
  jr    $ra

# 一个什么都不做的叶子函数，用于展示$ra寄存器没有发生变化
f2:
  # Return.
  jr    $ra

```

## 06c-TemporaryRegisterCC

```assembly
.text
# 一个使用临时寄存器中的有效值调用另一个函数的函数
# 这部分还要更高级一点
f1:
  # 由于需要调用子函数，我们需要保存ra
  addi  $sp, $sp, -4              
  sw    $ra, 0($sp)               

  # Execute some body code.
  # ...

  # 在程序中，我们必须调用另一个函数，但在函数调用后，我们需要使用临时寄存器中的一个值。我们说这个值是 "活 "的，因为它需要在将来使用。具体来说，我们可以将其描述为"跨越子程序调用 "的值。

  # 按照调用约定，临时寄存器可以由callee使用，而无需考虑之前寄存器中的值。但当一个函数是caller时，需要保存那些将来会用到的寄存器，这就是为什么我们称临时寄存器temporary registers为 caller saved registers

  # 注意，caller saved registers 包括 $t0-$t9, $a0-$a3, $v0, $v1.

  # 想象寄存器 $t2, $t6, $a0 中存储了一些将来还需要用到的值。
  # 我们需要对它们做一些对saved register一样的处理，但是有一点不同，那就是我们将在函数调用周围保存和恢复它们，而不是在函数的开头和结尾处。
  addi  $sp, $sp, -12

  # 保存寄存器
  sw    $t2, 0($sp)
  sw    $t6, 4($sp)
  sw    $a0, 8($sp)

  # 调用子函数
  jal   f2

  # 加载寄存器
  lw    $a0, 8($sp)
  lw    $t6, 4($sp)
  lw    $t2, 0($sp)

  # 恢复栈指针
  addi  $sp, $sp 12

  # 主体代码块,使用$t2, $t6, $a0为调用子函数之前的值.
  # ...

  # 返回之前我们需要恢复 $ra
  lw    $ra, 0($sp)
  addi  $sp, $sp, 4

  # 返回.
  jr    $ra

# 一个什么都不做的叶子函数，用于展示$ra寄存器没有发生变化
f2:
  # Return.
  jr    $ra

```

## 06d -SingleStackUnwind

```assembly
.text

  # 具有多个返回值但只有一个退出点的函数。
  # 这是一个更高级的话题。
f1:
  # 函数预处理，设置堆栈和保存寄存器
  addi  $sp, $sp, -20             # 分配5条指令的宽度
  sw    $ra, 0($sp)               # ra在第一个槽
  sw    $s0, 4($sp)               # $s0在第二个
  sw    $s1, 8($sp)               # $s1在第三个
  sw    $s2, 12($sp)              # $s2在第四个
  sw    $s3, 16($sp)              # $s3在第五个

  # 有时，我们希望函数能提前返回。比如
  # if (i < 0) { return value1; }
  # elif (i > 0) { return value2; }
  # else { return value3; }

  # 条件分支语句和代码块主体当然可以比这个复杂得多，但这是一个简单的例子。处理它最简单的方法就是精确地转换它。
  # 做出正确的决定，让程序流能跳转到正确的代码块；执行块中的代码；
  # 在 $v0 和 $v1 中设置返回值；展开你的堆栈；
  # 最后返回。
  # 这是很多重复的代码和很多故障点，因为您需要展开堆栈并在每个条件体中返回。第一部分是不可避免的：无论如何，您都需要执行代码并设置返回值。但是，如果您在一个地方管理堆栈增长，那么在同一个地方进行堆栈展开不是很好吗？如果你这样做，当决定改变你保存的寄存器（添加或删除）或以某种方式改变你的堆栈增长时，那么你只需要维护一个地方来展开。

  # 复杂的分支决策
  # ...

  #现在，在任何一个条件体中，跳转到一个共同的共享堆栈展开位置，在这里一切都会被清理干净。

_f1Body1:
  # 为第一种情况设置返回值的结果代码。
  # ...

  j     _unwind                   # Now jump to the cleanup section.

_f1Body2:
  # 为第二种情况设置返回值的结果代码。
  # ...

  j     _unwind                   # Now jump to the cleanup section.

_f1Body3:
  # 为第三种情况设置返回值的结果代码。
  # ...

  # 现在，既然接下来的指令是清理，我们就可以直接顺序执行通过了。

_unwind:
  # 这里的任何代码都只用于清理堆栈，因为我们不想扰乱任何寄存器。

  # 函数尾声，恢复寄存器并清理堆栈。
  lw    $s3, 16($sp)              # Restore $s3.
  lw    $s2, 12($sp)              # Restore $s2.
  lw    $s1, 8($sp)               # Restore $s1.
  lw    $s0, 4($sp)               # Restore $s0.
  lw    $ra, 0($sp)               # Restore $ra.
  addi  $sp, $sp, 20              # Deallocate five slots from the stack.

  # Return.
  jr    $ra

```

# 07-Kernel

```assembly
# 这是一个高级话题。
# 与内核交互会带来两个新部分：.ktext 和 .kdata。
# 内核数据部分（.kdata）的工作原理与常规数据部分完全相同。
# 唯一不同的是，.kdata 只能从 .ktext 访问。
.kdata
# 可以使用与 .data 部分完全相同的方式请求数据。
aWord:
  .word 0

# 可通过 .ktext 或 .text 访问。
.data

#.ktext部分与.data部分的代码跳转方式略有不同。处理器不需要跳转到标签，而是知道跳转到预定义的地址：0x80000180（对于我们的 MIPS* 版本）。我们可以通过在 .ktext 指令后添加地址来告诉一个section该从哪里开始。

# 任何异常发生时，处理器都会暂停正在运行的主程序并跳转到该地址。异常有两种不同类型：陷阱和中断。陷阱是同步异常的结果，这意味着它们是运行代码的结果。这些异常是代码中的某种错误，如除数为零或从错误的内存地址加载。中断是异步异常的结果，这意味着它们是由外部引起的。比如定时器寄存器与比较寄存器相匹配（定时器中断），或者有人按下键盘上的某个键（键盘中断）。
.ktext 0x80000180

  # 异常处理代码
  # ...

  # 如何从异常处理程序返回（针对我们的 MIPS** 版本）。
  eret

# 以下脚注基于 spim 的默认例外。 
# *：MIPS32。对于 MIPS-I (R2000)，此地址为 0x80000080。 
# **：MIPS-I (R2000) 使用手动获取 EPC 和 rfe # 指令的组合。

```

## 07b-start.s

```assembly
# 这是一个高级主题。
# __start 标签放在 .text 而不是 .ktext。
.text

# 人们通常认为main是程序的入口。实际上并非如此。程序实际上是从一个名为 __start 的标签开始的。C 语言也是如此，标准库在 __start 中提供了设置代码，最终调用 main。通常，SPIM 的 exception.s 中有一个 __start 来调用 main。如果你使用 -notrap 编写自己的异常处理程序，那么你就需要自己包含一个调用 main 的 __start 标签，或者直接从 __start 开始。__start 标签希望汇编程序能在任何地方找到它，因此必须使用 .globl 指令使它成为全局标签。

.globl __start
__start:
  # 程序设置代码。为主程序准备好 argc 和 argv 等参数。
  # ...

  # 调用主函数
  jal   main

	# 这是程序中的 "最高级 "代码，因此使用 "jr $ra" 没有任何意义，因为没有任何代码调用start。相反，我们使用系统调用来退出程序。
  li $v0 10  # 译者注：10 是系统调用号，对应于程序退出（终止）的系统调用。
  syscall

```

## 07c-RegistersSaving 

```assembly
# 这是一个高级话题。
# 与传统文本段的调用惯例类似,内核也必须保存寄存器。主要区别有两个：

# 1. 我们不能信任 $sp，所以我们不能使用堆栈。这需要将 # 值保存到 kdata 部分。

# 2. 在内核中，只有$k0和$k1可以自由使用。任何其他寄存器在使用之前都必须保存。这意味着您要使用的每个寄存器（$k0 和 $k1 除外）必须在静态内存中拥有一个槽。

# .kdata 部分可以为我们提供空间，以保存我们想要 # 使用的寄存器。
.kdata
rAT:
  .word 0
rS5:
  .word 0
rT3:
  .word 0

# Kernel code.
.ktext 0x80000180
  # 您必须始终考虑保存的第一个寄存器是 $at。$at 寄存器是汇编程序临时寄存器，在执行伪指令时用作中间保存寄存器。例如
  # li $t0, 0x11112222
  # 实际上是由这么两条指令组成的：
  # lui $at, 0x1111
  # ori $t0, $at, 0x2222

  # 我们之所以需要考虑这一点，是因为当我们进入异常处理程序时，我们不知道主程序是否在 lui 和ori 之间暂停过。这个原因与我们为什么要保存 $s0 这样的寄存器并无太大区别。我们不知道程序暂停时 $s0 是否在使用中，所以如果我们想使用它，就需要保存它。这里的区别在于，普通寄存器（如 $t0 或 $s0）必须由我们*显式*使用，而 $at 则总是*隐式*使用。使用 $at 可以让我们的生活更轻松。例如，我只需写一行代码，就能将 $s0 保存到 .ktext 部分的标签 rS5 中：
  # sw $s5, rs5
  #实际上是由这么两条指令组成的，使用$at：
  # lui $at, 0x9000
  # sw $s5, 4($at)

  #我们希望生活简单一些。如果我们想使用伪指令（我们几乎肯定会这样做），首先要做的就是保存 $at。

  # 由于 $at 的性质，它实际上受到汇编程序的保护。任何与 $at 明确交互的行为都会导致汇编程序语法错误。要保存 $at，我们必须先禁用它的保护。为此，我们使用带有 "noat "参数的 .set 指令。
  .set  noat

  # 接下来，我们需要将 $at MOVE 到 $k0 或 $k1。记住这一行
  # sw $at, rAT
  # 实际上是：
  # lui $at, 0x9000
  # sw $at, 0($at)
  # 这将在保存之前覆盖 $at，使其毫无用处。使用 la 也#好不了多少。例如，如果 .kdata 从 0x90001000 开始，那么
  # la $k0, rAT
  # sw $at, 0($k0)
  # 将会被扩展为：
  # lui $at, 0x9000
  # ori $k0, $at, 0x1000
  # sw $at, 0($k0)
  # 这也会在保存之前覆盖 $at。依旧毫无意义。最后，我们需要先复制它。
  move  $k0, $at

  #接下来我们需要重新启用对 $at 的保护。禁用保护对我们来说很危险。我们再次使用带有参数“at”的.set。
  .set  at
  # 既然我们已经存下了$at，那么我们可以存下所有我们需要保存的寄存器了，而不必担心at会被破坏。
  # 现在我们可以保存需要保存的寄存器了，因为我们已经保存了at。首先保存 $at：
  sw    $k0, rAT
  # 请记住，这是加载地址然后保存的简写
  # 像这样：
  # la $at, rAT
  # sw $k0, 0($at)

  # # 现在我们已经完成了 $at 的保存，我们可以保存其他寄存器了。再次强调，使用 $at 是安全的，所以我们会使用at
  sw    $s5, rS5
  sw    $t3, rT3

  # 异常处理程序代码放在这里。
  # ...

  # 现在是时候恢复我们使用过的所有寄存器了。我们应该首先恢复简单寄存器，因为我们还可以使用 $at。
  lw    $t3, rT3
  lw    $s5, rS5

  # 现在我们需要恢复 $at。最通俗易懂的方法就是撤销我们之前所做的一切：加载、取消保护、覆盖、保护。
  lw    $k0, rAT
  .set  noat
  move $at, $k0
  .set at

  # 从技术上讲，解除保护、直接加载、然后重新保护是安全的，因为最后一个操作是将加载的值写入 $at # 寄存器，没有机会更改该值。可以这样完成：
  # .set noat
  # lw $at, rAT
  # .set at
  # 会被扩展成这样：
  # .set noat
  # lui $at, 0x9000
  # lw $at, 0($at)
  # Which is safe.

  # 最后，从异常处理程序返回。
  eret

```

# syscall命令



| 作用       | $v0中的代码（2号寄存器） | 参数                              | 结果 |
| ---------- | ------------------------ | --------------------------------- | ---- |
| 打印整型   | 1                        | $a0(4号寄存器)存放要打印的整形    |      |
| 打印字符串 | 4                        | $a0存放以空字符结尾的字符串的地址 | ·    |
| 读取整型   | 5                        | $v                                |      |

# 其他的一些相关知识

## 伪操作

一般的汇编语言程序包含指令、伪操作、宏指令。伪操作也可称为伪指令，他是在汇编期间由汇编器处理的操作，用于指示程序的起始结束、定义数据、分配存储区。
这与计组课程里学到的“伪指令”稍有不同，pseudo instruction主要是切实存在的机器指令，为了便于程序员编程，使用了各种不在规定范围内的书写方式；伪操作和伪指令最终都是由汇编器处理成正常的机器码。

### 段选择

像所谓的`.text`段和`.data`段都是段选择的伪操作

`.data`段在程序运行过程中可以修改，.`rdata`段则不行。.`sdata`与data段很相似，不过可以使用gp在64KB的空间中进行寻址，所以只需要用16位地址就可以访问

## 对齐

.`align`通过指定2的指数幂，来为紧随其后的下一个数据指定一个大于正常要求的边界
`.align 4`指明以16B为对其边界

```assembly
	.align 4
var:
	dword 8
```

`.align 0`在MIPS中有特殊的作用

```assembly
.half 5	#这是一个正确对齐的半字
.align 0 #关闭自动对齐功能
.word 887 #前面存放了一个半字且关闭了自动对齐，所以只能将字对其到半字的边界

```

以上部分知识来自《MIPS体系结构与编程》。
